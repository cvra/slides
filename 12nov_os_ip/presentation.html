<html><head><meta charset="utf8"/><link rel="stylesheet" href="../reveal.js/css/reveal.min.css"/><link rel="stylesheet" href="custom.css" id="theme"/><link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css"/><title>RTOS, IP Stack & Message serialization</title></head><body><div class="reveal"><div class="slides"><section><h1>RTOS, Stack IP & Message serialization</h1><p>Antoine</p><p>Patrick S.</p></section><section><section><h2>RTOS</h2></section><section><h2>Fonction voulues</h2><ul><li>Multitasking</li><li>Preemptive scheduling</li><li>Priorities</li></ul></section><section><h2>État actuel</h2><ul><li>Compile</li><li>Fonctionnel d'après les premiers test</li></ul></section><section><h2>Que reste il à faire ?</h2><ol> <li>Écrire un guide sur le code multitask.</li><li>Rendre les modules existants thread safe.</li></ol></section></section><section><section><h2>IP Stack</h2></section><section><h2>Pourquoi une IP stack ?</h2><ul><li>Cool as fuck</li><li>Aggrandissable à nimporte quel nombre de boards / connexions</li><li>Debug facile avec un ordinateur (Wireshark)</li></ul></section><section><h2>Où en est-on ?</h2><ul><li>Compilation</li><li>Port de tout ce qui est lié à l'OS (sémaphores, mailboxes, etc..)</li></ul></section><section><h2>Qu'est-ce qu'il reste à faire ?</h2><ol><li>Modifier le driver UART pour le rendre utilisable avec la stack IP</li><li>Définir le moyen de communication entre nos robots<ul><li>WLAN</li><li>Bluetooth</li></ul></li><li>Tester</li></ol></section></section><section><section><h2>Message serialization</h2></section><section><h2>Pourquoi ?</h2><ul><li>Communiquer entre différents OS & plateformes</li><li>Différents languages de prog (C, Python, ...)</li><li>Éviter les répétitions de code</li></ul></section><section><h2>Qu'est-ce qu'il va faire ?</h2><ul><li>Lis un fichier qui définis des structures</li><li>Crée du code pour différents langages permettant de :</li><ul><li>Sérialiser la structure à partir de types natifs</li><li>Désérialiser à partir d'un flux de bytes vers les types natifs</li><li>Identifie le type du message à partir d'un hash de sa structure</li></ul></ul></section><section><h2>État actuel</h2><ul><li>Fichier de définition des structures lisibles et parsable</li><li>Génération du code en C fonctionnel mais incomplet</li></ul></section><section><h2>Tâches restantes</h2><ol><li>Finir le générateur de C</li><li>Écrire le générateur Python</li><li>Documenter</li></ol></section></section><section><section><h2>Planning</h2><ul><li>13.11 - 25.11 : Écriture d'une démo pour la ville de Renens</li><li>2 semaines : Test d'émission/réception avec le loopback</li><li>2 semaines : Finir le driver UART et PPPoS avec Linux</li><li>1 semaine : 30C3, écriture de doc</li><li>Nouvelle présentation à ce moment ?</li></ul><p>Simultanément : écriture du message serialization (hors réunions)</p></section></section><section><h2>#questions</h2></section></div></div><script src="../reveal.js/lib/js/head.min.js"></script><script src="../reveal.js/js/reveal.min.js"></script><script src="main.js"></script></body></html>